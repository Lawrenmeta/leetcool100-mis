当遇到向两个方向扩张的遍历情况时，最优的策略就应当是动态规划，这里动态规划的转移扩张以长度作为媒介，注意函数用法

```cpp
vector<vector<bool>> dp(len, vector<bool>(len, false));
return s.substr(begin, maxlen);
```

## 题目

给你一个字符串 `s`，找到 `s` 中最长的 回文 子串。

**示例 1：**

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。

```

**示例 2：**

```
输入：s = "cbbd"
输出："bb"

```

**提示：**

- `1 <= s.length <= 1000`
- `s` 仅由数字和英文字母组成

## 代码

```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        int len=s.size();
        if(len<2) return s;
        int maxlen=1;
        int begin=0;
        vector<vector<bool>> dp(len, vector<bool>(len, false));
        for(int i=0;i<len;i++){
            dp[i][i]=true;
        }

        for(int l=2;l<=len;l++){
            for(int i=0;i<len;i++){
                int j=l+i-1;
            if(j>=len){
                break;
            }
            if(s[i]!=s[j]){
                dp[i][j]=false;

            } else if(j-i<3){
                dp[i][j]=true;
            } else dp[i][j]=dp[i+1][j-1];

            if(dp[i][j]&&j-i+1>maxlen){
                maxlen=j-i+1;
                begin=i;
            }
            }   
        }
        return s.substr(begin, maxlen);
    }
};
```
