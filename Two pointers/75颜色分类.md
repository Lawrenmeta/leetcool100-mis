开始犯了快排的基本错误，觉得可以使用两个变量就能解决问题，但实际上变量交换有很多坑，需要对交换过程中的特殊数值进行检查，理论上一次交换只能区分一个二元组，逻辑关系的大于什么，小于什么，这个时候需要添加一个新的变量，然后还有一个重点是添加了变量之后，要确保交换的数值是经过检查的，所以如果写算法过程中依旧需要考虑去每一次操作的时候这个数的性质是否是算法想要的。

## 题目

给定一个包含红色、白色和蓝色、共 `n` 个元素的数组 `nums` ，**原地** 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

我们使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。

必须在不使用库内置的 sort 函数的情况下解决这个问题。你能想出一个仅使用常数空间的一趟扫描算法吗？

**输入：**nums = [2,0,2,1,1,0] **输出：**[0,0,1,1,2,2]

**输入：**nums = [2,0,1] **输出：**[0,1,2]

## 代码

```cpp
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int l=0,r=nums.size()-1;
        int c=0;
        while(c<r){
            if(num[c]==0){
                swap(nums[l],nums[c]);
                l++
                c++;
            }
            else if(nums[c]==2){
                swap(nums[r],nums[c]);
                // 注意：换回来的数还没检查，所以curr不能动
                r--;
            } else c++;
        }
    }
};
```
