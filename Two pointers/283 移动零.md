使用快慢指针解决问题，关键在于交换的这个过程交换过后应该移动zero，还有就是无论是否交换c都应该处理下一个数，因为zero=c的情况是无法移动的，必须有一个数先走，构建算法时尤其是边界还是需要手动推演一遍指针交叉时的特殊情况。

但最佳逻辑的解法是一个快慢指针的思想，一次性直接找到不是0的数，然后都整齐排列，这样的交换就符合三色的那个题最初的想法

## 题目

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

**示例 1:**

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]

```

**示例 2:**

```
输入: nums = [0]
输出: [0]
```

**提示**:

- `1 <= nums.length <= 104`
- `231 <= nums[i] <= 231 - 1`

**进阶：**你能尽量减少完成的操作次数吗？

## 代码

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int zero = 0; // 这里的 zero 理解为：当前可用的最靠前的“空位”（即0的位置）
        int c = 0;    // 这里的 c 理解为：当前正在检查的数
        int n = nums.size();

        while(c < n) {
            // 修改点1: 只有当 c 遇到非0数时，我们才考虑操作
            if (nums[c] == 0) {
                c++; 
                continue;
            }

            // 修改点2: 更新 zero 指针，让它指向第一个真正的 0
            // 注意：必须限制 zero < c，因为我们只关心 c 前面的 0
            while (zero < c && nums[zero] != 0) {
                zero++;
            }

            // 修改点3: 核心交换逻辑
            // 只有当发现 0 确实在当前非0数 (c) 的前面时，才交换
            if (zero < c) { 
                swap(nums[c], nums[zero]);
                zero++; // 交换完，这个位置已经是非0了，zero指针要往后移
            }
            
            // 无论是否交换，c 都要处理下一个数了
            c++;
        }
    }
};
```

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int left = 0; // 慢指针：指向下一个非零元素应该存放的位置
        int n = nums.size();
        
        // right 是快指针：负责遍历数组
        for (int right = 0; right < n; right++) {
            // 如果快指针遇到了非零元素
            if (nums[right] != 0) {
                // 将其与慢指针位置交换
                swap(nums[left], nums[right]);
                // 慢指针向前移动一步
                left++;
            }
        }
    }
};
```
