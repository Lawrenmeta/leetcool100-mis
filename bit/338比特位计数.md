该题采用的方案是根据最高位的变化次序来判断的一个做法，整数数组中1的个数会有一个阶段性的规律，因为之前的前几位运算和后来是一样的，所有能显现出一种规律，当最高位是10和11时，底下的位数变化会和上一个轮回的变化有重复，利用这个思想就可以实现一个简单的动态规划。

但是我的视角里依旧有局限，没有想着更大开大合的方法，只是停在了一个表面的位置，没有思考更优雅的解法，着迷在了简单的运算里。

## 题目

给你一个整数 `n` ，对于 `0 <= i <= n` 中的每个 `i` ，计算其二进制表示中 **`1` 的个数** ，返回一个长度为 `n + 1` 的数组 `ans` 作为答案。

**示例 1：**

```
输入：n = 2
输出：[0,1,1]
解释：
0 --> 0
1 --> 1
2 --> 10

```

**示例 2：**

```
输入：n = 5
输出：[0,1,1,2,1,2]
解释：
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101

```

**提示：**

- `0 <= n <= 105`

## 代码

### 位运算

```cpp
class Solution {
public:
    int countOnes(int x) {
        int ones = 0;
        while (x > 0) {
            x &= (x - 1);
            ones++;
        }
        return ones;
    }

    vector<int> countBits(int n) {
        vector<int> bits(n + 1);
        for (int i = 0; i <= n; i++) {
            bits[i] = countOnes(i);
        }
        return bits;
    }
};

```

### 动态规划

```cpp
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> bits(n + 1);
        int highBit = 0;
        for (int i = 1; i <= n; i++) {
            if ((i & (i - 1)) == 0) {
                highBit = i;
            }
            bits[i] = bits[i - highBit] + 1;
        }
        return bits;
    }
};

```

### 一般规律解法

```cpp
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> ans(n+1);
        if(n==0) return {0};
        ans[0]=0;
        ans[1]=1;
        int c=0;
        for(int i=2;i<=n;i++){
            int w= floor(log2(i));
            int k= ceil(log2(i));
            c++;
            if(w==k){
                ans[i]=1;
                c = 1;
            } else {
                int move= 1 << (w-1);
                if (c<=(1 << (w-1))){
                    ans[i] = ans[i-move];
                 } else {
                    ans[i] = ans[i-move]+1;
                 }
            }
        }
        return ans;
    }
};
```

可使用变量维护的方案优化算法，以及适当的数学推导化简
