可以使用常规的库函数nth_element解决问题，但是也能使用快速排序、堆排序等算法解决问题，此例子中快速排序算法的要点是当我这样不把快速排序的每一个中心点单独储存时，我每一次其实都在交换那个中心元素放到一个合适的位置。堆的性质主要是根节点永远大于叶节点，所以堆的构建函数就是从理论的最末叶子结点n/2-1这个位置向上使用堆的交换算法，从下往上筛选出最大的元素，每一次交换再维系叶子节点；堆真正用于排序时，算法便是每次都把理论上下的元素放到堆顶，然后堆顶的两个叶子节点中肯定含有第二大的数，类似于这个过程就能实现排序。

## 问题

给定整数数组 `nums` 和整数 `k`，请返回数组中第 **`k`** 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1:**

```
输入: [3,2,1,5,6,4], k = 2
输出: 5

```

**示例 2:**

```
输入: [3,2,3,1,2,4,5,5,6],k = 4
输出: 4
```

## 代码

### nth_element

```cpp

class Solution {
public:
    int findKthLargest(std::vector<int>& nums, int k) {
        int n = nums.size();
        // 将第 (n - k) 小的元素放到正确位置，即第 k 大的元素
        nth_element(nums.begin(), nums.begin() + n - k, nums.end());
        return nums[n - k];
    }
};
```

### 快速排序

```cpp
class Solution {
public:
    int quickselect(vector<int> &nums, int l, int r, int k) {
        if (l == r)
            return nums[k];
        int partition = nums[l], i = l - 1, j = r + 1;
        #这是为了之后的do i++ j--那里不用重置逻辑
        while (i < j) {
            do i++; while (nums[i] < partition);
            #注意，这里第一次比较就会把需要置于中心的元素放到一个相对合适的位置
            do j--; while (nums[j] > partition);
            if (i < j)
                swap(nums[i], nums[j]);
        }
        if (k <= j)return quickselect(nums, l, j, k);
        else return quickselect(nums, j + 1, r, k);
    }

    int findKthLargest(vector<int> &nums, int k) {
        int n = nums.size();
        return quickselect(nums, 0, n - 1, n - k);
    }
};

```

### 堆排序

```cpp
class Solution {
public:
    void heapify(vector<int> &nums,int i,int n){
    //堆排序操作函数，核心逻辑是堆的排序是在2n+1和2n+2，这个区间中找的
        int l=i*2+1 ,r =i*2+2,lagest=i;
        if( l<n && nums[l]>nums[lagest]){
            lagest=l;
        }
        if(r<n && nums[r]>nums[lagest]){
            lagest=r;
        }
        if(lagest!=i){
            swap(nums[lagest],nums[i]);
            heapify(nums,lagest,n);
            //交换后继续递归排序
        }

    }
    void build(vector<int> &nums, int n){
        for(int i=n/2-1;i>=0;--i){
            heapify(nums,i,n);
        }
    }
    int findKthLargest(std::vector<int>& nums, int k) {
        int n = nums.size();
        build(nums,n);
        int size=n;
        for(int i=n-1;i>=n+1-k;i--){
            swap(nums[0],nums[i]);
            --size;
            heapify(nums,0,size);    
        }
        return nums[0];
    }
};

```
