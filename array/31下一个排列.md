# 31下一个队列
题设有些复杂，说明了很多不同的情况，要求字典排序最少，本质上就是从一个顺序升序的序列，一步步找到变化后仍然由这些数字组成的稍大一些的排列

代码

```cpp
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int i = nums.size() - 2;
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i--;
        }
        #从后向前找到第一个乱序降序的地方，说明这个地方存在一点变得更大的可能，只要是按照顺序变大的，这一点可能就是变化一点使其增大的最优可能
        if (i >= 0) {
            int j = nums.size() - 1;
            while (j >= 0 && nums[i] >= nums[j]) {
                j--;
            }
            swap(nums[i], nums[j]);
        }
        reverse(nums.begin() + i + 1, nums.end());
        #善用reverse函数
    }
};

```
