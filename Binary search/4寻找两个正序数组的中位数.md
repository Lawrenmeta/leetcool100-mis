可直接使用快速排序法进行操作，但在重新写快速排序时遇到问题：1需要明确什么时候操作l，什么时候r，什么时候i，什么时候j，需要记住除以2.0才能变成浮点数，然后记住快拍的两边边界，如果使用l作为标准，一定是j和j+1。

官方解法学习总结：分割线的思想很容易想到，但存在很多的特殊情况需要顾及，边界中会存在分割线另行讨论（通过m+n+1除以2），在元素个数太少的时候可能出现死循环也需要考虑

## 题目

给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。

算法的时间复杂度应该为 `O(log (m+n))` 。

**示例 1：**

```
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2

```

**示例 2：**

```
输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5

```

**提示：**

- `nums1.length == m`
- `nums2.length == n`
- `0 <= m <= 1000`
- `0 <= n <= 1000`
- `1 <= m + n <= 2000`
- `106 <= nums1[i], nums2[i] <= 106`

## 代码

```cpp
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        if (nums1.size() > nums2.size()) {
            return findMedianSortedArrays(nums2, nums1);
        }
        
        int m = nums1.size();
        int n = nums2.size();
        int left = 0, right = m;
        // median1：前一部分的最大值
        // median2：后一部分的最小值
        int median1 = 0, median2 = 0;

        while (left <= right) {
            // 前一部分包含 nums1[0 .. i-1] 和 nums2[0 .. j-1]
            // 后一部分包含 nums1[i .. m-1] 和 nums2[j .. n-1]
            int i = (left + right) / 2;
            int j = (m + n + 1) / 2 - i;

            // nums_im1, nums_i, nums_jm1, nums_j 分别表示 nums1[i-1], nums1[i], nums2[j-1], nums2[j]
            int nums_im1 = (i == 0 ? INT_MIN : nums1[i - 1]);
            int nums_i = (i == m ? INT_MAX : nums1[i]);
            int nums_jm1 = (j == 0 ? INT_MIN : nums2[j - 1]);
            int nums_j = (j == n ? INT_MAX : nums2[j]);

            if (nums_im1 <= nums_j) {
                median1 = max(nums_im1, nums_jm1);
                median2 = min(nums_i, nums_j);
                left = i + 1;
            } else {
                right = i - 1;
            }
        }

        return (m + n) % 2 == 0 ? (median1 + median2) / 2.0 : median1;
    }
};

```

```cpp
class Solution {
public:
    void quick(vector<int> &nums, int l,int r){
        if(l==r) return;
        int pre=nums[l],i=l-1,j=r+1;
        while(i<j){
            do i++; while(nums[i]<pre);
            do j--; while(nums[j]>pre);
            if(i<j) swap(nums[i],nums[j]);
        }
        
        quick(nums,l,j);
        quick(nums,j+1,r);
    }
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        for(int i=0;i<nums2.size();i++){
            nums1.push_back(nums2[i]);
        }
        int n =nums1.size()-1;
        quick(nums1,0,n);
        double a=0;
        if(n%2==1){
            a=(nums1[n/2]+nums1[n/2+1])/2.0;
            return a;
        } else {
            return nums1[n/2];
        }
    }
};
```
