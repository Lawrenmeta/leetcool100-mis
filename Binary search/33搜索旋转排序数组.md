目前个人采用思路是将数组重置回升序数组之后再进行二分查找，最后再进行逻辑修正，这里需要注意的是，二分查找使用i+j+1 除以2时，要确保mid是正确的mid，这点很重要，其次是所有的循环一定要检查边界，以及要灵活使用取余运算

标准答案更加大开大合，标准答案的做法需要找的就是通过列举四种情况来讨论该在哪个区间找到怒nums，最终只是为了找到nums，分别讨论当前二分区间是否存在target

## 题目

整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。

在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **向左旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,5,6,7]` 下标 `3` 上向左旋转后可能变为 `[4,5,6,7,0,1,2]` 。

给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

**示例 1：**

```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4

```

**示例 2：**

```
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
```

**示例 3：**

```
输入：nums = [1], target = 0
输出：-1

```

**提示：**

- `1 <= nums.length <= 5000`
- `104 <= nums[i] <= 104`
- `nums` 中的每个值都 **独一无二**
- 题目数据保证 `nums` 在预先未知的某个下标上进行了旋转
- `104 <= target <= 104`

## 代码

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int i=0,j=nums.size()-1,mid=0;
        int n = nums.size();
        if(j==0){
            if(nums[j]==target){
                return j;
            } else{
                return -1;
            }

        }
        int k=0;
        int d=0;
        while(d < nums.size() && nums[d]<nums[d+1]){
            rotate(nums.begin(), nums.begin() + 1, nums.end());
            k++;
            if(d==nums.size()-1) break;
        }
        rotate(nums.begin(), nums.begin() + 1, nums.end());
        k++;
        while(i<j){
            mid=(i+j+1)/2;
            if(nums[mid]<target) i=mid;
            if(nums[mid]>target) j=mi-1;
            if(nums[mid]==target) break;
        }
        mid=(i+j+1)/2;//关键
        if (nums[mid] != target) {

                return -1; // 真的没找到
            }
        return (mid+k) % n;
    }
};
```

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = (int)nums.size();
        if (!n) {
            return -1;
        }
        if (n == 1) {
            return nums[0] == target ? 0 : -1;
        }
        int l = 0, r = n - 1;
        while (l <= r) {
            int mid = (l + r) / 2;
            if (nums[mid] == target) return mid;
            if (nums[0] <= nums[mid]) {
                if (nums[0] <= target && target < nums[mid]) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            } else {
                if (nums[mid] < target && target <= nums[n - 1]) {
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
        }
        return -1;
    }
};

作者：力扣官方题解
链接：https://leetcode.cn/problems/search-in-rotated-sorted-array/solutions/220083/sou-suo-xuan-zhuan-pai-xu-shu-zu-by-leetcode-solut/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
